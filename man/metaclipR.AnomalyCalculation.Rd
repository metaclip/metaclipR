% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metaclipR.AnomalyCalculation.R
\name{metaclipR.AnomalyCalculation}
\alias{metaclipR.AnomalyCalculation}
\title{Directed metadata graph construction for Anomaly transformations}
\usage{
metaclipR.AnomalyCalculation(graph, package = "transformeR",
  version = "1.4.1", fun = "scaleGrid", arg.list = NULL,
  referenceGraph = NULL)
}
\arguments{
\item{graph}{An output from a previous \pkg{metaclipR} function containing a list with the i-graph class object containing
the input grid whose anomaly is to be computed, plus the terminal node from which the Anomaly Step will hang}

\item{package}{package}

\item{version}{version}

\item{fun}{function name. Unused (set to \code{"localScaling"})}

\item{arg.list}{Either a character string containing a literal command call or a key-value pair list of arguments-values. See the dedicated section more for details.}

\item{referenceGraph}{An output from a previous \pkg{metaclipR} function containing a list with the i-graph class object containing the reference Transformation-class object
used as base to compute the climatology, plus the name of its terminal node}
}
\description{
Build a directed metadata graph describing an anomaly Transformation on a 
climate4R grid
}
\details{
This function takes as reference the semantics defined in the Data Source and Transformation ontology
defined in the Metaclip Framework (\url{http://www.metaclip.org}).
}
\section{About argument lists}{

Argument lists are key-value list in which the different arguments and their valus are passed 
to the command description. These were initially conceived as an adequate means of describing
command calls to interpreted languajes (R, python...) using both the Argument and Argument 
classes from the datasource vocabulary of METACLIP.

Alternatively, and in order to accomodate the description of the source code to other environments
and languajes (e.g. shell scripts, calls to CDOs etc.), the use of literal command calls 
is a more convenient choice. Literal command calls also allow for a more straightforward
reproducibility by just "copying and pasting" the code used to generate each step. Literal
command calls are encoded in METACLIP using the \emph{hadLiteralCommandCall} data property
from the datasource vocabulary, that is attached to the command description. 
To apply this second alternative, the \code{arg.list} argument is specified as a character string
containing the command call.

Note that default argument values are often omitted from comand calls. However, the default behaviour of 
commands may change depending on the specific software version, and it is therefore often advisable to 
explicitly include the default argument values for a more straightforward interpretation of the source code
by the user.
}

\examples{
require(transformeR)
require(igraph)
pkg <- "transformeR"
v <- "1.1.1"
# Assume a given hindcast DatasetSubset: 
data("CFS_Iberia_psl")
# In this example it is assumed that the 1983-1990 partition is the hindcast
# (the reference period used to compute the anomaly), and that the 2002 subset
# is the operational forecast for that year. 
# Note that the dataset is daily:
getTimeResolution(CFS_Iberia_psl)

# First, a dataset subset of just 3 members is created as example. The DatasetSubset initializes
# the graph in this example

psl <- subsetGrid(CFS_Iberia_psl, members = 1:3)
metadata <- metaclipR.DatasetSubset(package = pkg,
                                    version = v,
                                    fun = "subsetGrid",
                                    output = "psl",
                                    arg.list = list("members" = 1:3))
                                         
plot.igraph(metadata$graph, vertex.size = 5, edge.arrow.size = 0.1)
                                         
# Annual data are calculated via aggregation: 

CFS.psl.annual <- aggregateGrid(psl,
                                aggr.m = list(FUN = "mean", na.rm = TRUE),
                                aggr.y = list(FUN = "mean", na.rm = TRUE))
# and the corresponding metadata added to the graph:
metadata <- metaclipR.Aggregation(graph = metadata,
                                  package = pkg,
                                  version = v,
                                  fun = "aggregateGrid",
                                  arg.list = list("aggr.m" = list(FUN = "mean", na.rm = TRUE),
                                                  "aggr.y" = list(FUN = "mean", na.rm = TRUE)))

plot.igraph(metadata$graph, vertex.size = 5, edge.arrow.size = 0.1)

# Next the baseline period used as reference for anomaly calculation is subset:
ref <- subsetGrid(CFS.psl.annual, years = 1983:1990)

metadata <- metaclipR.DatasetSubset(package = pkg,
                                    graph = metadata,
                                    version = v,
                                    fun = "subsetGrid",
                                    output = "ref",
                                    arg.list = list("years" = 1983:1990))
                                         
plot.igraph(metadata$graph, vertex.size = 5, edge.arrow.size = 0.1)

# The same is done for the "fake" operative forecast for 2002, 
#     assumed to come from a different dataset:
fcst <- subsetGrid(CFS.psl.annual, years = 2002)
# THE FORECAST IS ADDED TO A NEW GRAPH. However,
# no linking property between hindcast and forecast is indicated 
metadata2 <- metaclipR.DatasetSubset(package = pkg,
                                     version = v,
                                     arg.list = list("years" = 2002),
                                     output = "fcst")
                                          
plot.igraph(metadata2$graph, vertex.size = 5, edge.arrow.size = 0.1)

# The function scaleGrid is used to compute anomalies. 
# In its default setup, it subtracts the climatology (mean) of the input grid:
anom <- scaleGrid(grid = fcst,
                  base = ref,
                  ref = NULL,
                  time.frame = "none",
                  by.member = TRUE)
# This is the argument list (the data arrays are indicated as character 
     # strings to avoid  a congested graph):
arg.list = list("grid" = "fcst",
                "base" = "ref",
                "ref" = NULL,
                "clim.fun" = list(FUN = mean, na.rm = TRUE),
                "by.member" = TRUE,
                "time.frame" = "none")

# The metadata of the anomaly calculation is next encoded. 
# Note that two different graphs are used as input:
#  i) The graph containing the steps to produce the baseline data, 
#         used as reference to compute the anomalies
#  ii) The graph containing the data upon which the anomalies are to be calculated

out <- metaclipR.AnomalyCalculation(graph = metadata2,
                                    package = pkg,
                                    version = v,
                                    fun = "scaleGrid",
                                    arg.list = arg.list,
                                    referenceGraph = metadata)

plot.igraph(out$graph, vertex.size = 5, edge.arrow.size = 0.1)
}
\seealso{
Other transformation: \code{\link{metaclip.graph.Command}},
  \code{\link{metaclipR.Aggregation}},
  \code{\link{metaclipR.Climatology}},
  \code{\link{metaclipR.Dataset}},
  \code{\link{metaclipR.Ensemble}},
  \code{\link{metaclipR.Interpolation}},
  \code{\link{metaclipR.etccdi}}
}
\author{
D. San MartÃ­n, J. Bedia
}
\concept{transformation}
